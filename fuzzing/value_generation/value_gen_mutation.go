package value_generation

import (
	"github.com/trailofbits/medusa/utils"
	"math/big"
)

// integerRandomBias defines the probability a generated integer will be entirely random rather than mutated from base
// integers.
const integerRandomBias = 0.2

// stringRandomBias defines the probability a generated string will be entirely random rather than mutated from base
// strings.
const stringRandomBias = 0.2

// bytesRandomBias defines the probability a generated byte array will be entirely random rather than mutated from base
// byte arrays.
const bytesRandomBias = 0.2

// ValueGeneratorMutation is a provider used to generate function inputs and call arguments using mutation-based
// approaches against items within a base_value_set.BaseValueSet, such as AST literals.
type ValueGeneratorMutation struct {
	// baseIntegers represents the base integer values to be used in mutations.
	baseIntegers []*big.Int
	// baseStrings represents the base strings values to be used in mutations.
	baseStrings []string
	// baseBytes represents the base byte arrays to be used in mutations.
	baseBytes [][]byte

	maxMutationRounds int

	// ValueGeneratorRandom is included to inherit from the random generator
	*ValueGeneratorRandom
}

// NewValueGeneratorMutation creates a new ValueGeneratorMutation using a provided base_value_set.BaseValueSet to seed base-values for mutation.
func NewValueGeneratorMutation(baseValueSet *BaseValueSet) *ValueGeneratorMutation {
	// Obtain our list of integers as a big int pointer array.
	baseValueSetIntegers := baseValueSet.Integers()
	formattedBaseIntegers := make([]*big.Int, len(baseValueSetIntegers))
	for i := 0; i < len(baseValueSetIntegers); i++ {
		formattedBaseIntegers[i] = &baseValueSetIntegers[i]
	}

	// Create and return our generator
	generator := &ValueGeneratorMutation{
		baseIntegers:         formattedBaseIntegers,
		baseStrings:          baseValueSet.Strings(),
		baseBytes:            baseValueSet.Bytes(),
		maxMutationRounds:    3,
		ValueGeneratorRandom: NewValueGeneratorRandom(),
	}
	return generator
}

// integerMutationMethods define methods which take a big integer and a set of inputs and
// transform the integer with a random input and operation. This is used in a loop to create
// mutated integer values.
var integerMutationMethods = []func(*ValueGeneratorMutation, *big.Int, ...*big.Int) *big.Int{
	func(g *ValueGeneratorMutation, x *big.Int, inputs ...*big.Int) *big.Int {
		// Add a random input
		return big.NewInt(0).Add(x, inputs[g.randomProvider.Int()%len(inputs)])
	},
	func(g *ValueGeneratorMutation, x *big.Int, inputs ...*big.Int) *big.Int {
		// Subtract a random input
		return big.NewInt(0).Sub(x, inputs[g.randomProvider.Int()%len(inputs)])
	},
	func(g *ValueGeneratorMutation, x *big.Int, inputs ...*big.Int) *big.Int {
		// Multiply a random input
		return big.NewInt(0).Mul(x, inputs[g.randomProvider.Int()%len(inputs)])
	},
	func(g *ValueGeneratorMutation, x *big.Int, inputs ...*big.Int) *big.Int {
		// Divide a random input
		divisor := inputs[g.randomProvider.Int()%len(inputs)]
		if divisor.Cmp(big.NewInt(0)) == 0 {
			return big.NewInt(1) // leave unchanged if divisor was zero (would've caused panic)
		}
		return big.NewInt(0).Div(x, divisor)
	},
	func(g *ValueGeneratorMutation, x *big.Int, inputs ...*big.Int) *big.Int {
		// Modulo divide a random input
		divisor := inputs[g.randomProvider.Int()%len(inputs)]
		if divisor.Cmp(big.NewInt(0)) == 0 {
			return big.NewInt(0).Set(x) // leave unchanged if divisor was zero (would've caused panic)
		}
		return big.NewInt(0).Mod(x, divisor)
	},
}

var bytesMutationMethods = []func(*ValueGeneratorMutation, []byte, ...[]byte) []byte{
	// Replace a random index with a random byte
	func(g *ValueGeneratorMutation, b []byte, inputs ...[]byte) []byte {
		b[g.randomProvider.Int()%len(b)] = byte(g.randomProvider.Int() % 256)
		return b
	},
	// Flip a random byte
	func(g *ValueGeneratorMutation, b []byte, inputs ...[]byte) []byte {
		i := g.randomProvider.Int() % len(b)
		b[i] = b[i] ^ (1 << (g.randomProvider.Int() % 8))
		return b
	},
	// Add a random byte at a random position
	func(g *ValueGeneratorMutation, b []byte, inputs ...[]byte) []byte {
		i := g.randomProvider.Int() % len(b)
		by := byte(g.randomProvider.Int() % 256)
		if len(b) == 0 {
			return []byte{by}
		} else if i >= len(b) {
			return append(b, by)
		} else {
			return append(b[:i], append([]byte{by}, b[i:]...)...)
		}
	},
	// Remove a random byte
	func(g *ValueGeneratorMutation, b []byte, inputs ...[]byte) []byte {
		i := g.randomProvider.Int() % len(b)
		return append(b[:i], b[i+1:]...)
	},
}

var stringMutationMethods = []func(*ValueGeneratorMutation, string, ...string) string{
	// Replace a random index with a random character
	func(g *ValueGeneratorMutation, s string, inputs ...string) string {
		r := []rune(s)
		r[g.randomProvider.Int()%len(s)] = rune(32 + g.randomProvider.Int()%95)
		return string(r)
	},
	// Flip a random bit
	func(g *ValueGeneratorMutation, s string, inputs ...string) string {
		r := []rune(s)
		i := g.randomProvider.Int() % len(s)
		r[i] = r[i] ^ (1 << (g.randomProvider.Int() % 8))
		return string(r)
	},
	// Add a random character at a random position
	func(g *ValueGeneratorMutation, s string, inputs ...string) string {
		i := g.randomProvider.Int() % len(s)
		c := string(rune(32 + g.randomProvider.Int()%95))
		return s[:i] + c + s[i+1:]
	},
	// Remove a random character
	func(g *ValueGeneratorMutation, s string, inputs ...string) string {
		i := g.randomProvider.Int() % len(s)
		return s[:i] + s[i+1:]
	},
}

func (g *ValueGeneratorMutation) getMutationParams(inputsLen int) (int, int) {
	g.randomProviderLock.Lock()
	inputIdx := g.randomProvider.Int() % inputsLen
	mutationCount := g.randomProvider.Int() % (g.maxMutationRounds + 1)
	g.randomProviderLock.Unlock()

	return inputIdx, mutationCount
}

// GenerateInteger generates/selects an integer to use when populating inputs.
func (g *ValueGeneratorMutation) GenerateInteger(signed bool, bitLength int) *big.Int {
	// If our bias directs us to, use the random generator instead
	g.randomProviderLock.Lock()
	randomGeneratorDecision := g.randomProvider.Float32()
	g.randomProviderLock.Unlock()
	if randomGeneratorDecision < integerRandomBias {
		return g.ValueGeneratorRandom.GenerateInteger(signed, bitLength)
	}

	// Calculate our integer bounds
	min, max := utils.GetIntegerConstraints(signed, bitLength)

	// Determine additional inputs based off the value type
	var inputs []*big.Int
	inputs = append(inputs, g.baseIntegers...)
	if signed {
		inputs = append(inputs, big.NewInt(0), big.NewInt(1), big.NewInt(-1), big.NewInt(2), min, max)
	} else {
		inputs = append(inputs, big.NewInt(1), big.NewInt(2), min, max) // zero is included in minimum
	}

	inputIdx, mutationCount := g.getMutationParams(len(inputs))
	input := inputs[inputIdx]

	for i := 0; i < mutationCount; i++ {
		// Mutate input
		g.randomProviderLock.Lock()
		input = integerMutationMethods[g.randomProvider.Int()%len(integerMutationMethods)](g, input, inputs...)
		g.randomProviderLock.Unlock()

		// Correct value boundaries (underflow/overflow)
		input = utils.ConstrainIntegerToBounds(input, min, max)
	}
	return input
}

func (g *ValueGeneratorMutation) GenerateBytes() []byte {
	// If we have no inputs or our bias directs us to, use the random generator instead
	inputs := g.baseBytes
	g.randomProviderLock.Lock()
	randomGeneratorDecision := g.randomProvider.Float32()
	g.randomProviderLock.Unlock()
	if len(inputs) == 0 || randomGeneratorDecision < bytesRandomBias {
		return g.ValueGeneratorRandom.GenerateBytes()
	}

	// Create a copy of a random input to mutate
	inputIdx, mutationCount := g.getMutationParams(len(inputs))
	input := make([]byte, len(inputs[inputIdx]))
	copy(input, inputs[inputIdx])

	// Mutate the data for our desired number of rounds
	for i := 0; i < mutationCount; i++ {
		g.randomProviderLock.Lock()
		input = bytesMutationMethods[g.randomProvider.Int()%len(bytesMutationMethods)](g, input, inputs...)
		g.randomProviderLock.Unlock()
	}

	return input
}

func (g *ValueGeneratorMutation) GenerateString() string {
	// If we have no inputs or our bias directs us to, use the random generator instead
	inputs := g.baseStrings
	g.randomProviderLock.Lock()
	randomGeneratorDecision := g.randomProvider.Float32()
	g.randomProviderLock.Unlock()
	if len(inputs) == 0 || randomGeneratorDecision < stringRandomBias {
		return g.ValueGeneratorRandom.GenerateString()
	}

	// Obtain a random input to mutate
	inputIdx, mutationCount := g.getMutationParams(len(inputs))
	input := inputs[inputIdx]

	// Mutate the data for our desired number of rounds
	for i := 0; i < mutationCount; i++ {
		g.randomProviderLock.Lock()
		input = stringMutationMethods[g.randomProvider.Int()%len(stringMutationMethods)](g, input, inputs...)
		g.randomProviderLock.Unlock()
	}

	return input
}
